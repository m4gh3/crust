/*
 * Copyright (C) 2021 m4gh3
 * 
 * This file is part of m4gpiler.
    m4gpiler is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    m4gpiler is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    You should have received a copy of the GNU General Public License
    along with m4gpiler.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "rrextab.hpp"
#include "lazyfied_ostream.hpp"
#include "typetree.hpp"
#include <fstream>

{:token_names:
	START:
	L_PAR:
	L_SEMICOLON:
	L_SUM:
	L_SUB:
	L_PROD:
	L_UNARY_MINUS:
	NUM:
	IDENT:
	PAR:
	UNARY_MINUS:
	PROD:
	SUB:
	SUM:
	SEMICOLON
:}

struct lang_value
{
	int64_t prec_token;
	TypeTree *type;

	//Storage Type
	enum SType_t
	{
		NONE,
		LOCAL,
		LVAL,
		RVAL,
		CONST
	};

	SType_t stype;

	std::any data;
};

inline int data_to_int(lang_value *l)
{ return std::any_cast<int>(l->data); }

/*inline std::any &get_data(void *l)
{ return ((lang_value *)l)->data; }*/

std::vector<std::unordered_map<std::string, std::any >> scope_stack;
TypeTree *type_int;

void lang_callbacks(int64_t reduce, match_shared_t &m, circ_buf_t<int64_t, 3 > &next_redbuf, void *&_lval, void *&_rval )
{

	lang_value *&lval = *(lang_value **)&_lval;
	lang_value *&rval = *(lang_value **)&_rval;

	m.redbuf->push_head(((lang_value *)lval)->prec_token);
	switch(reduce)
	{
		case L_PAR:
			{
				rval = new lang_value{START, type_int, lang_value::NONE, 0};
			}
			break;
		case L_SEMICOLON:
			{
				(*m.os) << data_to_int(lval) << std::endl;
				rval = new lang_value{L_SEMICOLON, type_int, lang_value::NONE, 0};
			}
			break;
		case L_SUM:
			{
				rval = new lang_value{L_SUM, type_int, lang_value::NONE, 0};
			}
			break;
		case L_SUB:
			{
				rval = new lang_value{L_SUB, type_int, lang_value::NONE, 0};
			}
		case L_PROD:
			{
				rval = new lang_value{L_PROD, type_int, lang_value::NONE, 0};
			}
			break;
		case L_UNARY_MINUS:
			{
				rval = new lang_value{L_UNARY_MINUS, type_int, lang_value::NONE, 0};
			}
			break;
		case NUM:
			{
				lval->data = 0;
				for(int i=0; i < m.ret[0]-m.offset; i++ )
					lval->data = data_to_int(lval)*10 + ((*m.buf)[i]-'0');
			}
			break;
		case IDENT:
			{
				/*std::string ident;
				for(int i=0; i < m.ret[0]-m.offset; i++ )
					ident.push_back((*m.buf)[i]);*/
				//lval->data = ident;
				lval->data = 0;	
			}
			break;
		case PAR:
			{
				lval->data = data_to_int(rval);
				lval->stype = lang_value::RVAL;
			}
			break;
		case UNARY_MINUS:
			{
				lval->data = data_to_int(lval) - data_to_int(rval);
				lval->stype = lang_value::RVAL;
				delete (lang_value *)rval;
			}
			break;
		case PROD:
			{
				lval->data = data_to_int(lval) * data_to_int(rval);
				lval->stype = lang_value::RVAL;
				delete (lang_value *)rval;
			}
			break;
		case SUB:
			{
				lval->data = data_to_int(lval) - data_to_int(rval);
				lval->stype = lang_value::RVAL;
				delete (lang_value *)rval;
			}
			break;
		case SUM:
			{
				lval->data = data_to_int(lval) + data_to_int(rval);
				lval->stype = lang_value::RVAL;
				delete (lang_value *)rval;
			}
			break;
		case SEMICOLON:
			{
				rval->prec_token = lval->prec_token;
				(*lval) = (*rval); //can't you just copy the value?
				delete ((lang_value *)rval);
			}
	}
}

int main(int argc, char **argv )
{

	{:parser_rules:
		START,L_UNARY_MINUS '0','9' -> NUM|DO_CALLBACK
		NUM|DO_CALLBACK '0','9' -> NUM|DO_CALLBACK

		START,L_UNARY_MINUS '_','_' -> IDENT|DO_CALLBACK
		START,L_UNARY_MINUS 'a','z' -> IDENT|DO_CALLBACK
		IDENT|DO_CALLBACK 'a','z' -> IDENT|DO_CALLBACK
		START,L_UNARY_MINUS 'A','Z' -> IDENT|DO_CALLBACK
		IDENT|DO_CALLBACK 'A','Z' -> IDENT|DO_CALLBACK
		IDENT|DO_CALLBACK '0','9' -> IDENT|DO_CALLBACK
		IDENT|DO_CALLBACK '_','_' -> IDENT|DO_CALLBACK

		START,L_UNARY_MINUS '-' -> L_UNARY_MINUS|DO_RECURSION|DO_CALLBACK
		START,L_UNARY_MINUS L_UNARY_MINUS NUM,UNARY_MINUS -> UNARY_MINUS|DO_CALLBACK

		START,L_UNARY_MINUS '(' -> L_PAR|DO_CALLBACK|DO_RECURSION
		START,L_UNARY_MINUS L_PAR NUM,SEMICOLON ')' -> PAR|DO_CALLBACK

		START,L_UNARY_MINUS '{' -> L_PAR|DO_CALLBACK|DO_RECURSION
		START,L_UNARY_MINUS L_PAR NUM,SEMICOLON '}' -> PAR|DO_CALLBACK

		START NUM,SEMICOLON ';' -> L_SEMICOLON|DO_CALLBACK|DO_RECURSION
		START L_SEMICOLON NUM,SUM -> SEMICOLON|DO_CALLBACK

		START,L_SEMICOLON NUM,SUM '+' -> L_SUM|DO_CALLBACK|DO_RECURSION
		START,L_SEMICOLON L_SUM NUM,PROD -> SUM|DO_CALLBACK

		START,L_SEMICOLON NUM,SUM '-' -> L_SUB|DO_CALLBACK|DO_RECURSION
		START,L_SEMICOLON L_SUB NUM,PROD -> SUB|DO_CALLBACK

		START,L_SUM NUM,PROD '*' -> L_PROD|DO_CALLBACK|DO_RECURSION
		START,L_SUM L_PROD NUM,UNARY_MINUS -> PROD|DO_CALLBACK
	:}

	type_int = &base_types["int"];

	//std::cout << "rrex_tree sz:" << rrex_tree_size(rrex_main_tree_ptr) << std::endl;
	//std::cout << "START = " << START <<std::endl;

	int64_t ret[3]={0,-1};
	circ_buf_t<int64_t, 3 > redbuf; redbuf.push_head(START);

	if( argc < 3 )
	{
		match
		(
				rrex_main_tree_ptr,
				ret,
				matchbuf,
				redbuf,
				new lang_value{START, 0},
				std::cin,
				std::cout
		);
	}
	else
	{
		std::ifstream ifile(argv[1], std::ifstream::in );
		std::ofstream ofile(argv[2], std::ofstream::out );
		match
		(
				rrex_main_tree_ptr,
				ret,
				matchbuf,
				redbuf,
				new lang_value{START, 0},
				ifile,
				ofile
		);
	}

	//std::cout << std::endl;
	return 0;

}

// vim:ft=cpp
