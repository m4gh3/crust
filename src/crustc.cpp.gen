/*
 * Copyright (C) 2021 m4gh3
 * 
 * This file is part of m4gpiler.
    m4gpiler is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    m4gpiler is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    You should have received a copy of the GNU General Public License
    along with m4gpiler.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "rrextab.hpp"
#include "lazyfied_ostream.hpp"
#include "typetree.hpp"


{:token_names:
	START:
	L_PAR:
	L_SEMICOLON:
	L_SUM:
	L_SUB:
	L_PROD:
	L_UNARY_MINUS:
	NUM:
	IDENT:
	PAR:
	UNARY_MINUS:
	PROD:
	SUB:
	SUM:
	SEMICOLON
:}

struct lang_value
{
    int64_t prec_token;
    TypeTree *type;
    std::any data;
};

inline int to_int(void *l)
{ return std::any_cast<int>(((lang_value*)l)->data); }

inline std::any &get_data(void *l)
{ return ((lang_value *)l)->data; }

std::vector<std::unordered_map<std::string, std::any >> scope_stack;
TypeTree *type_int;

void lang_callbacks(int64_t reduce, match_shared_t &m, circ_buf_t<int64_t, 3 > &next_redbuf, void *&lval, void *&rval )
{
	m.redbuf->push_head(((lang_value *)lval)->prec_token);
	switch(reduce)
	{
		case L_PAR:
			{
				rval = new lang_value{START, type_int, 0};
			}
			break;
		case L_SEMICOLON:
			{
				std::cout << to_int(lval) << std::endl;
				rval = new lang_value{L_SEMICOLON, type_int, 0};
			}
			break;
		case L_SUM:
			{
				rval = new lang_value{L_SUM, type_int, 0};
			}
			break;
		case L_SUB:
			{
				rval = new lang_value{L_SUB, type_int, 0};
			}
		case L_PROD:
			{
				rval = new lang_value{L_PROD, type_int, 0};
			}
			break;
		case L_UNARY_MINUS:
			{
				rval = new lang_value{L_UNARY_MINUS, type_int, 0};
			}
			break;
		case NUM:
			{
				get_data(lval) = 0;
				//int &retval = get_data(lval);
				for(int i=0; i < m.ret[0]-m.offset; i++ )
					get_data(lval) = to_int(lval)*10 + ((*m.buf)[i]-'0');
			}
			break;
		case IDENT:
			{
				get_data(lval) = 0;
			}
			break;
		case PAR:
			{
				get_data(lval) = to_int(rval);
			}
			break;
		case UNARY_MINUS:
			{
				get_data(lval) = to_int(lval) - to_int(rval);
				delete (lang_value *)rval;
			}
			break;
		case PROD:
			{
				get_data(lval) = to_int(lval) * to_int(rval);
				delete (lang_value *)rval;
			}
			break;
		case SUB:
			{
				get_data(lval) = to_int(lval) - to_int(rval);
				delete (lang_value *)rval;
			}
			break;
		case SUM:
			{
				get_data(lval) = to_int(lval) + to_int(rval);
				delete (lang_value *)rval;
			}
			break;
		case SEMICOLON:
			{
				get_data(lval) = to_int(rval);
				delete ((lang_value *)rval);
			}
	}
}

int main()
{
	{:parser_rules:
		START,L_UNARY_MINUS '0','9' -> NUM|DO_CALLBACK
		NUM|DO_CALLBACK '0','9' -> NUM|DO_CALLBACK

		START,L_UNARY_MINUS '_','_' -> IDENT|DO_CALLBACK
		START,L_UNARY_MINUS 'a','z' -> IDENT|DO_CALLBACK
		IDENT|DO_CALLBACK 'a','z' -> IDENT|DO_CALLBACK
		START,L_UNARY_MINUS 'A','Z' -> IDENT|DO_CALLBACK
		IDENT|DO_CALLBACK 'A','Z' -> IDENT|DO_CALLBACK
		IDENT|DO_CALLBACK '0','9' -> IDENT|DO_CALLBACK
		IDENT|DO_CALLBACK '_','_' -> IDENT|DO_CALLBACK

		START,L_UNARY_MINUS '-' -> L_UNARY_MINUS|DO_RECURSION|DO_CALLBACK
		START,L_UNARY_MINUS L_UNARY_MINUS NUM,UNARY_MINUS -> UNARY_MINUS|DO_CALLBACK

		START,L_UNARY_MINUS '(' -> L_PAR|DO_CALLBACK|DO_RECURSION
		START,L_UNARY_MINUS L_PAR NUM,SEMICOLON ')' -> PAR|DO_CALLBACK

		START,L_UNARY_MINUS '{' -> L_PAR|DO_CALLBACK|DO_RECURSION
		START,L_UNARY_MINUS L_PAR NUM,SEMICOLON '}' -> PAR|DO_CALLBACK

		START NUM,SEMICOLON ';' -> L_SEMICOLON|DO_CALLBACK|DO_RECURSION
		START L_SEMICOLON NUM,SUM -> SEMICOLON|DO_CALLBACK

		START,L_SEMICOLON NUM,SUM '+' -> L_SUM|DO_CALLBACK|DO_RECURSION
		START,L_SEMICOLON L_SUM NUM,PROD -> SUM|DO_CALLBACK

		START,L_SEMICOLON NUM,SUM '-' -> L_SUB|DO_CALLBACK|DO_RECURSION
		START,L_SEMICOLON L_SUB NUM,PROD -> SUB|DO_CALLBACK

		START,L_SUM NUM,PROD '*' -> L_PROD|DO_CALLBACK|DO_RECURSION
		START,L_SUM L_PROD NUM,UNARY_MINUS -> PROD|DO_CALLBACK
	:}
	type_int = &base_types["int"];
	std::cout << "rrex_tree sz:" << rrex_tree_size(rrex_main_tree_ptr) << std::endl;
	std::cout << "START = " << START <<std::endl;
	int64_t ret[3]={0,-1};
	circ_buf_t<int64_t, 3 > redbuf; redbuf.push_head(START);
	match(rrex_main_tree_ptr, ret, matchbuf, redbuf, new lang_value{START, 0}, std::cin, std::cout );
	std::cout << std::endl;
	return 0;
}

// vim:ft=cpp
